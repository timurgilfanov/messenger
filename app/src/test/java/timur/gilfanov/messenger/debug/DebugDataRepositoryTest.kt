package timur.gilfanov.messenger.debug

import app.cash.turbine.test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue
import kotlinx.collections.immutable.ImmutableList
import kotlinx.collections.immutable.toImmutableList
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.emptyFlow
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.test.StandardTestDispatcher
import kotlinx.coroutines.test.TestScope
import kotlinx.coroutines.test.advanceTimeBy
import kotlinx.coroutines.test.runTest
import org.junit.Before
import org.junit.Test
import org.junit.experimental.categories.Category
import org.junit.runner.RunWith
import org.robolectric.RobolectricTestRunner
import timur.gilfanov.messenger.data.source.local.LocalDataSourceFake
import timur.gilfanov.messenger.data.source.local.LocalDebugDataSource
import timur.gilfanov.messenger.data.source.remote.RemoteDataSourceError
import timur.gilfanov.messenger.data.source.remote.RemoteDebugDataSource
import timur.gilfanov.messenger.domain.entity.ResultWithError
import timur.gilfanov.messenger.domain.entity.chat.Chat
import timur.gilfanov.messenger.domain.entity.chat.ChatPreview
import timur.gilfanov.messenger.domain.entity.message.Message

@RunWith(RobolectricTestRunner::class)
@Category(Unit::class)
class DebugDataRepositoryTest {

    private lateinit var dataStore: DebugTestData.FakeDataStore

    private lateinit var localDebugDataSource: LocalDebugDataSource
    private lateinit var remoteDebugDataSource: RemoteDebugDataSource
    private lateinit var sampleDataProvider: SampleDataProvider
    private lateinit var testScope: TestScope
    private lateinit var logger: TrackingTestLogger
    private lateinit var debugDataRepository: DebugDataRepository

    @OptIn(ExperimentalCoroutinesApi::class)
    @Before
    fun setup() {
        logger = TrackingTestLogger()
        dataStore = DebugTestData.createTestDataStore()
        remoteDebugDataSource = FakeRemoteDebugDataSource()
        sampleDataProvider = SampleDataProvider()
        testScope = TestScope(StandardTestDispatcher())
        localDebugDataSource = LocalDataSourceFake(logger)

        debugDataRepository = DebugDataRepositoryImpl(
            localDebugDataSource = localDebugDataSource,
            remoteDebugDataSource = remoteDebugDataSource,
            sampleDataProvider = sampleDataProvider,
            coroutineScope = testScope.backgroundScope,
            logger = logger,
        )
    }

    @Test
    fun `debugSettings flow emits correct initial settings`() = testScope.runTest {
        // When
        debugDataRepository.settings.test {
            val settings = awaitItem()

            // Then
            assertEquals(DataScenario.STANDARD, settings.scenario)
            assertFalse(settings.autoActivity)
            assertTrue(settings.showNotification)
            assertNull(settings.lastGenerationTimestamp)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `initializeWithScenario clears data and generates new data`() = testScope.runTest {
        // Given
        val scenario = DataScenario.MINIMAL

        // When
        debugDataRepository.initializeWithScenario(scenario)

        // Then - Verify data generation - check that chats were added to remote
        assertTrue(remoteDebugDataSource.getChats().isNotEmpty())
        assertEquals(scenario.chatCount, remoteDebugDataSource.getChats().size)

        // Verify settings update
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertEquals(scenario, settings.scenario)
            assertNotNull(settings.lastGenerationTimestamp)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `regenerateData uses current scenario from settings`() = testScope.runTest {
        // Given - Set initial scenario
        debugDataRepository.updateSettings { current ->
            current.copy(scenario = DataScenario.EDGE_CASES)
        }

        // When
        debugDataRepository.regenerateData()

        // Then - Verify data was regenerated by checking added chats
        assertTrue(remoteDebugDataSource.getChats().isNotEmpty())
        assertEquals(DataScenario.EDGE_CASES.chatCount, remoteDebugDataSource.getChats().size)
    }

    @Test
    fun `clearAllData clears both local and remote data`() = testScope.runTest {
        // When
        debugDataRepository.clearData()

        // Then
        // TODO import fake and test assertEquals(0, localDebugDataSource.getChats().size)
        assertEquals(0, remoteDebugDataSource.getChats().size)
    }

    @Test
    fun `updateSettings modifies datastore preferences`() = testScope.runTest {
        // When
        debugDataRepository.updateSettings { current ->
            current.copy(
                scenario = DataScenario.DEMO,
                autoActivity = true,
                showNotification = false,
            )
        }

        // Then
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertEquals(DataScenario.DEMO, settings.scenario)
            assertTrue(settings.autoActivity)
            assertFalse(settings.showNotification)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `getScenario returns scenario from preferences`() = testScope.runTest {
        // Given - Set a scenario in preferences
        debugDataRepository.updateSettings { current ->
            current.copy(scenario = DataScenario.HEAVY)
        }

        // When
        val savedScenario = debugDataRepository.settings.first().scenario

        // Then
        assertEquals(DataScenario.HEAVY, savedScenario)
    }

    @Test
    fun `setAutoActivity updates settings and controls auto activity`() = testScope.runTest {
        // When - Enable auto activity
        debugDataRepository.updateSettings { settings -> settings.copy(autoActivity = true) }

        // Then - Verify settings updated
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertTrue(settings.autoActivity)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `setNotification updates notification setting`() = testScope.runTest {
        // When
        debugDataRepository.updateSettings { settings -> settings.copy(showNotification = false) }

        // Then
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertFalse(settings.showNotification)
            cancelAndIgnoreRemainingEvents()
        }
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    @Test
    fun `auto activity starts when enabled via settings`() = testScope.runTest {
        // Given - Setup chats for simulation
        val testChat = DebugTestData.createTestChat()
        remoteDebugDataSource.addChat(testChat)
        val initialMessageCount = remoteDebugDataSource.getMessagesSize()

        // When - Enable auto activity
        debugDataRepository.updateSettings { settings -> settings.copy(autoActivity = true) }

        // Then - Verify the setting is enabled
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertTrue(settings.autoActivity, "Auto activity should be enabled")
            cancelAndIgnoreRemainingEvents()
        }

        // Note: We can't reliably test message generation timing in this test
        // because backgroundScope runs independently of test time control
    }

    @Test
    fun `handles local data source errors gracefully`() = testScope.runTest {
        // Given - Local data source fails
//        localDebugDataSource.shouldFailDeleteAllChats = true

        // When
        debugDataRepository.initializeWithScenario(DataScenario.STANDARD)

        // Then - Should continue despite errors and log them
//        assertTrue(localDebugDataSource.wasDeleteAllChatsCalled)
//        assertTrue(logger.warnLogs.isNotEmpty())
    }

    @Test
    fun `handles data generation errors gracefully`() = testScope.runTest {
        // Given - Simulate error by making local data source fail
//        localDebugDataSource.shouldFailDeleteAllChats = true

        // When - Initialize should still complete
        debugDataRepository.initializeWithScenario(DataScenario.STANDARD)

        // Then - Should handle error gracefully and still generate data
//        assertTrue(localDebugDataSource.wasDeleteAllChatsCalled)
        // Data should still be generated despite local clearing failures
        assertTrue(remoteDebugDataSource.getChats().isNotEmpty())
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    @Test
    fun `auto activity stops when disabled`() = testScope.runTest {
        // Given - Auto activity is running
        val testChat = DebugTestData.createTestChat()
        remoteDebugDataSource.addChat(testChat)

        debugDataRepository.updateSettings { settings -> settings.copy(autoActivity = true) }
        advanceTimeBy(6000L) // Trigger first message

        val initialMessageCount = remoteDebugDataSource.getMessagesSize()

        // When - Disable auto activity
        debugDataRepository.updateSettings { settings -> settings.copy(autoActivity = false) }
        advanceTimeBy(10000L)

        // Then - No more messages should be generated after disabling
        assertEquals(initialMessageCount, remoteDebugDataSource.getMessagesSize())
    }

    @Test
    fun `regenerateData updates last generation timestamp`() = testScope.runTest {
        // Given - Get initial timestamp
        val initialLastGeneration =
            debugDataRepository.settings.first().lastGenerationTimestamp

        // When
        debugDataRepository.regenerateData()

        // Then
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertTrue(
                settings.lastGenerationTimestamp != initialLastGeneration,
                "Last generation should be updated after regenerating data",
            )
            cancelAndIgnoreRemainingEvents()
        }
    }

    @Test
    fun `component integrates all dependencies correctly`() = testScope.runTest {
        // Given
        val scenario = DataScenario.DEMO

        // When - Perform full initialization flow
        debugDataRepository.initializeWithScenario(scenario)

        // Then - Verify all components are called in correct sequence
        assertEquals(scenario.chatCount, remoteDebugDataSource.getChats().size)

        // Verify final state
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertEquals(scenario, settings.scenario)
            assertEquals(scenario.chatCount, settings.scenario.chatCount)
            assertNotNull(settings.lastGenerationTimestamp)
        }
    }

    /**
     * Fake implementation of LocalDebugDataSource for testing
     */
//    private class FakeLocalDebugDataSource : LocalDebugDataSource {
//        var wasDeleteAllChatsCalled = false
//        var wasDeleteAllMessagesCalled = false
//        var wasClearSyncTimestampCalled = false
//        var shouldFailDeleteAllChats = false
//        var shouldFailDeleteAllMessages = false
//        var shouldFailClearSyncTimestamp = false
//
//        override val settings: Flow<DebugSettings> = flowOf(DebugSettings())
//
//        override suspend fun deleteAllChats(): ResultWithError<Unit, LocalDataSourceError> {
//            wasDeleteAllChatsCalled = true
//            return if (shouldFailDeleteAllChats) {
//                ResultWithError.Failure(
//                    LocalDataSourceError.UnknownError(
//                        java.sql.SQLException("Failed to delete chats"),
//                    ),
//                )
//            } else {
//                ResultWithError.Success(Unit)
//            }
//        }
//
//        override suspend fun deleteAllMessages(): ResultWithError<Unit, LocalDataSourceError> {
//            wasDeleteAllMessagesCalled = true
//            return if (shouldFailDeleteAllMessages) {
//                ResultWithError.Failure(
//                    LocalDataSourceError.UnknownError(
//                        java.sql.SQLException("Failed to delete messages"),
//                    ),
//                )
//            } else {
//                ResultWithError.Success(Unit)
//            }
//        }
//
//        override suspend fun clearSyncTimestamp(): ResultWithError<Unit, LocalDataSourceError> {
//            wasClearSyncTimestampCalled = true
//            return if (shouldFailClearSyncTimestamp) {
//                ResultWithError.Failure(
//                    LocalDataSourceError.SettingsWriteError(
//                        java.io.IOException("Failed to clear sync timestamp"),
//                    ),
//                )
//            } else {
//                ResultWithError.Success(Unit)
//            }
//        }
//
//        override suspend fun updateSettings(
//            transform: (DebugSettings) -> DebugSettings,
//        ): ResultWithError<Unit, LocalUpdateSettingsError> {
//            transform(settings)
//            return ResultWithError.Success(Unit)
//        }
//
//        override suspend fun getSettings(): ResultWithError<DebugSettings, LocalGetSettingsError> =
//            ResultWithError.Success(settings)
//    }

    /**
     * Fake implementation of RemoteDebugDataSource for testing
     */
    private class FakeRemoteDebugDataSource : RemoteDebugDataSource {
        var wasClearServerDataCalled = false
        private val chats = mutableListOf<Chat>()
        private val messages = mutableListOf<Message>()

        override fun clearData() {
            wasClearServerDataCalled = true
            chats.clear()
            messages.clear()
        }

        override fun addChat(chat: Chat) {
            chats.add(chat)
        }

        override fun addMessage(message: Message) {
            messages.add(message)
        }

        override fun getChats(): ImmutableList<Chat> = chats.toImmutableList()
        override fun getMessagesSize(): Int = messages.size

        override val chatPreviews: Flow<ResultWithError<List<ChatPreview>, RemoteDataSourceError>> =
            emptyFlow()
    }

    // Regression test for sync integration
    @Test
    fun `initializeWithScenario generates data that syncs correctly`() = testScope.runTest {
        // Given - Create a mock sync flow to verify the generated data can be synced
        val generatedChats = mutableListOf<Chat>()

        // Spy on the sync behavior by capturing what's added to remote
        val spyRemoteDebugDataSource = object : RemoteDebugDataSource {
            override fun clearData() {
                // No-op for test
            }

            override fun addChat(chat: Chat) {
                generatedChats.add(chat)
            }

            override fun addMessage(message: Message) {
                // No-op for test
            }

            override fun getChats(): ImmutableList<Chat> {
                error("Not needed for this test")
            }

            override fun getMessagesSize(): Int {
                error("Not needed for this test")
            }

            override val chatPreviews:
                Flow<ResultWithError<List<ChatPreview>, RemoteDataSourceError>> = emptyFlow()
        }

        // Recreate repository with the spy
        debugDataRepository = DebugDataRepositoryImpl(
            localDebugDataSource = localDebugDataSource,
            remoteDebugDataSource = spyRemoteDebugDataSource,
            sampleDataProvider = sampleDataProvider,
            coroutineScope = testScope.backgroundScope,
            logger = logger,
        )

        // When - Initialize with scenario
        val scenario = DataScenario.DEMO
        debugDataRepository.initializeWithScenario(scenario)

        // Then - Verify data was generated with proper sync-compatible format
        assertTrue(generatedChats.isNotEmpty(), "Should generate chats")
        assertEquals(scenario.chatCount, generatedChats.size)

        // Verify the generated chats have valid structure for sync
        generatedChats.forEach { chat ->
            // Chat should have valid ID
            assertTrue(chat.id.id.toString().isNotEmpty())

            // Messages should have correct recipient (this was the original bug)
            chat.messages.forEach { message ->
                assertEquals(
                    chat.id,
                    message.recipient,
                    "Message recipient should match chat ID for sync to work correctly",
                )
            }

            // Should have participants
            assertTrue(chat.participants.isNotEmpty())

            // Should have messages (DEMO scenario should have conversations)
            assertTrue(chat.messages.isNotEmpty())
        }

        // Verify settings were updated correctly
        debugDataRepository.settings.test {
            val settings = awaitItem()
            assertEquals(scenario, settings.scenario)
            assertNotNull(settings.lastGenerationTimestamp) { "Should record generation timestamp" }
            cancelAndIgnoreRemainingEvents()
        }
    }
}
